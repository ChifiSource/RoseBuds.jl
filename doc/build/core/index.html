<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>core · toolips</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="toolips logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">toolips</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">toolips</a></li><li><a class="tocitem" href="../projects/">projects</a></li><li class="is-active"><a class="tocitem" href>core</a><ul class="internal"><li><a class="tocitem" href="#requests"><span>requests</span></a></li><li><a class="tocitem" href="#connections"><span>connections</span></a></li><li><a class="tocitem" href="#routing"><span>routing</span></a></li><li><a class="tocitem" href="#servers"><span>servers</span></a></li><li><a class="tocitem" href="#server-extensions"><span>server extensions</span></a></li></ul></li><li><a class="tocitem" href="../servables/">servables</a></li><li><a class="tocitem" href="../toolips_session/">sessions</a></li><li><a class="tocitem" href="../developer_api/">developer api</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>core</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>core</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChifiSource/Toolips.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="core"><a class="docs-heading-anchor" href="#core">core</a><a id="core-1"></a><a class="docs-heading-anchor-permalink" href="#core" title="Permalink"></a></h1><p>Below is a runthrough of all of the documentation pertaining to running a Toolips server.</p><h2 id="requests"><a class="docs-heading-anchor" href="#requests">requests</a><a id="requests-1"></a><a class="docs-heading-anchor-permalink" href="#requests" title="Permalink"></a></h2><p>Toolips has some bindings that pre-parse responses fro you, these are both post and get requests.</p><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>get() -&gt; ::Dict</strong></p><hr/><p>Quick binding for an HTTP GET request.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.post" href="#Toolips.post"><code>Toolips.post</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>post() -&gt;</strong></p><hr/><p>Quick binding for an HTTP POST request.</p><p><strong>example</strong></p></div></section></article><h2 id="connections"><a class="docs-heading-anchor" href="#connections">connections</a><a id="connections-1"></a><a class="docs-heading-anchor-permalink" href="#connections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Toolips.Connection" href="#Toolips.Connection"><code>Toolips.Connection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Connection</strong></p><ul><li>routes::Dict</li><li>http::HTTP.Stream</li><li>extensions::Dict</li></ul><p>The connection type is passed into route functions and pages as an argument. This is both for functions, as well as Servable.f() methods. This constructor     should not be called directly. Instead, it is called by the server and     passed through the function pipeline. Indexing a Connection will return         the extension named with that symbol.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">                  #  v The Connection
home = route(&quot;/&quot;) do c::Connection
    c[Logger].log(1, &quot;We can index extensions by type or symbol&quot;)
    c[:logger].log(1, &quot;see?&quot;)
    c.routes[&quot;/&quot;] = c::Connection -&gt; write!(c, &quot;rerouting!&quot;)
    httpstream = c.http
    write!(c, &quot;Hello world!&quot;)
    myheading::Component = h(&quot;myheading&quot;, 1, text = &quot;Whoa!&quot;)
    write!(c, myheading)
end</code></pre><hr/><p><strong>field info</strong></p><ul><li><strong>routes::Dict</strong> - A dictionary of routes where the keys</li></ul><p>are the routed URL and the values are the functions to those keys.</p><ul><li><strong>http::HTTP.Stream</strong> - The stream for this current peer&#39;s connection.</li><li><strong>extensions::Dict</strong> - A dictionary of extensions to load with the</li></ul><p><strong>name to reference as keys and the extension as the pair.</strong></p><p><strong>constructors</strong></p><ul><li>Connection(routes::Dict, http::HTTP.Stream, extensions::Dict)</li></ul></div></section></article><p>Connections are served as an argument to incoming routes. Functions are written anticipating a connection return. Here we will write a new route using the route(::Function, ::String) method.</p>Route{Function}(&quot;/&quot;, Main.EvalBlockSandbox.var&quot;#1#2&quot;())<p>We also use the write!() method on our Connection. We can use this on the types ::Any, ::Vector{Servable}, and ::Servable.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!-Tuple{Connection, Any}" href="#Toolips.write!-Tuple{Connection, Any}"><code>Toolips.write!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>write!(::Connection, ::Any) -&gt; _</strong></p><hr/><p>Attempts to write any type to the Connection&#39;s stream.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!-Tuple{Connection, String}" href="#Toolips.write!-Tuple{Connection, String}"><code>Toolips.write!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>write!(::Connection, ::String) -&gt; _</strong></p><hr/><p>Writes the String into the Connection as HTML.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!-Tuple{Connection, Vararg{Servable}}" href="#Toolips.write!-Tuple{Connection, Vararg{Servable}}"><code>Toolips.write!</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!-Tuple{Connection, Vector{Servable}}" href="#Toolips.write!-Tuple{Connection, Vector{Servable}}"><code>Toolips.write!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>write!(c::Connection, s::Vector{Servable}) -&gt; _</strong></p><hr/><p>Writes, in order of element, each Servable inside of a Vector of Servables.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!-Tuple{Connection, Servable}" href="#Toolips.write!-Tuple{Connection, Servable}"><code>Toolips.write!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>write!(::Connection, ::Servable) -&gt; _</strong></p><hr/><p>Writes a Servable&#39;s return to a Connection&#39;s stream.</p><p><strong>example</strong></p></div></section></article><p>Or push any data response into a body and startread the body.</p><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Tuple{Connection, Any}" href="#Base.push!-Tuple{Connection, Any}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>startread!(::Connection, ::Any)</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The connection type can be indexed with Symbols, Strings, and Types. Symbols and Types will index the extensions. Strings will index the routes. The same goes for setting the indexes.</p><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Connection, Symbol}" href="#Base.getindex-Tuple{Connection, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getindex(::Connection, ::Type)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Connection, String}" href="#Base.getindex-Tuple{Connection, String}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><p>We also use the Connection in order to get arguments, download files, and pretty much anything else pertaining to a person&#39;s connection.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.getarg" href="#Toolips.getarg"><code>Toolips.getarg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getargs(::Connection, ::Symbol) -&gt; ::Dict</strong></p><hr/><p>Returns the requested arguments from the target.</p><p><strong>example</strong></p></div></section><section><div><p><strong>Interface</strong></p><p><strong>getarg(::Connection, ::Symbol, ::Type) -&gt; ::Vector</strong></p><hr/><p>This method is the same as getargs(::HTTP.Stream, ::Symbol), however types are parsed as type T(). Note that &quot;Cannot convert...&quot; errors are possible with this method.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getargs" href="#Toolips.getargs"><code>Toolips.getargs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getargs(::Connection) -&gt; ::Dict</strong></p><hr/><p>The getargs method returns arguments from the HTTP header (GET requests.) Returns a full dictionary of these values.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getip" href="#Toolips.getip"><code>Toolips.getip</code></a> — <span class="docstring-category">Function</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.postarg" href="#Toolips.postarg"><code>Toolips.postarg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>postarg(::Connection, ::String) -&gt; ::Any</strong></p><hr/><p>Get a body argument of a POST response by name.</p><p><strong>example</strong></p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getpost</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Toolips.postargs" href="#Toolips.postargs"><code>Toolips.postargs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>postargs(::Connection, ::Symbol, ::Type) -&gt; ::Dict</strong></p><hr/><p>Get arguments from the request body.</p><p><strong>example</strong></p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>download!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Toolips.navigate!" href="#Toolips.navigate!"><code>Toolips.navigate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>navigate!(::Connection, ::String) -&gt; _</strong></p><hr/><p>Routes a connected stream to a given URL.</p><p><strong>example</strong></p></div></section></article><p>We can also check if an extension is present by type.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_extension(::Connection, ::Type)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="routing"><a class="docs-heading-anchor" href="#routing">routing</a><a id="routing-1"></a><a class="docs-heading-anchor-permalink" href="#routing" title="Permalink"></a></h2><p>When routing, many methods involve the <strong>Connection</strong> type we just spoke of. In toolips, routes are handled by the Route type.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.Route" href="#Toolips.Route"><code>Toolips.Route</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Route{T}</strong></p><ul><li>path::String</li><li>page::T A route is added to a ServerTemplate using either its constructor, or the</li></ul><p>ServerTemplate.add(::Route) method. Each route calls either a particular servable or function; the type of which denoted by T. The Route type is     commonly constructed using the do syntax with the route(::Function, String)     method.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs"># Constructors
route = Route(&quot;/&quot;, p(text = &quot;hello&quot;))

function example(c::Connection)
    write!(c, &quot;hello&quot;)
end

route = Route(&quot;/&quot;, example)

# method
route = route(&quot;/&quot;) do c
    write!(c, &quot;Hello world!&quot;)
    write!(c, p(text = &quot;hello&quot;))
    # we can also use extensions!
    c[:logger].log(&quot;hello world!&quot;)
end</code></pre><hr/><p><strong>field info</strong></p><ul><li><strong>path::String</strong></li></ul><p>The path, e.g. &quot;/&quot; at which to direct to the given component.</p><ul><li><strong>page::T</strong> (::Function || T &lt;: Component)</li></ul><p><strong>The servable to serve at this given route.</strong></p><p><strong>constructors</strong></p><ul><li>Route(path::String, f::Function) <strong>where</strong></li><li>Route(path::String, s::Servable)</li></ul></div></section></article><p>The Route&#39;s constructors are not typically called directly, instead it is probably better to use these methods. Using route! as opposed to route! will modify the routes of a Connection or ToolipsServer</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.route" href="#Toolips.route"><code>Toolips.route</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>route(::Function, ::String) -&gt; ::Route</strong></p><hr/><p>Creates a route from the Function.</p><p><strong>example</strong></p></div></section><section><div></div></section><section><div><p><strong>Interface</strong></p><p><strong>route(::String, ::Servable) -&gt; ::Route</strong></p><hr/><p>Creates a route from a Servable.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route!" href="#Toolips.route!"><code>Toolips.route!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>route!(::Connection, ::Route) -&gt; _</strong></p><hr/><p>Modifies the routes on the Connection.</p><p><strong>example</strong></p></div></section><section><div><p><strong>Interface</strong></p><p><strong>route!(::Function, ::Connection, ::String) -&gt; _</strong></p><hr/><p>Routes a given String to the Function.</p><p><strong>example</strong></p></div></section><section><div></div></section><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.unroute!" href="#Toolips.unroute!"><code>Toolips.unroute!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>unroute!(::Connection, ::String) -&gt; _</strong></p><hr/><p>Removes the route with the key equivalent to the String.</p><p><strong>example</strong></p></div></section></article><h2 id="servers"><a class="docs-heading-anchor" href="#servers">servers</a><a id="servers-1"></a><a class="docs-heading-anchor-permalink" href="#servers" title="Permalink"></a></h2><p>ToolipsServers are created by ServerTemplates. Here is a look at how to make a ServerTemplate:</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.ServerTemplate" href="#Toolips.ServerTemplate"><code>Toolips.ServerTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>ServerTemplate</strong></p><ul><li>ip<strong>::String</strong></li><li>port<strong>::Integer</strong></li><li>routes<strong>::Vector{Route}</strong></li><li>extensions<strong>::Dict</strong></li><li>remove<strong>::Function</strong></li><li>add<strong>::Function</strong></li><li>start<strong>::Function</strong> The ServerTemplate is used to configure a server before</li></ul><p>running. These are usually made and started inside of a main server file.</p><p><strong>example</strong></p><hr/><p><strong>field info</strong></p><ul><li>ip<strong>::String</strong></li><li>port<strong>::Integer</strong></li><li>routes<strong>::Vector{Route}</strong></li><li>extensions<strong>::Dict</strong></li><li>remove<strong>::Function</strong></li><li>add<strong>::Function</strong></li><li>start<strong>::Function</strong></li></ul><hr/><p><strong>constructors</strong></p><p>ServerTemplate(ip::String = &quot;127.0.0.1&quot;, port::Int64 = 8001,             routes::Dict = Vector{Route}()); extensions::Dict = Dict(:logger =&gt; Logger())</p></div></section></article><p>The ServerTemplate.start() function returns a sub-type of ToolipsServer.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.ToolipsServer" href="#Toolips.ToolipsServer"><code>Toolips.ToolipsServer</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type ToolipsServer</strong></p><p>ToolipsServers are returned whenever the ServerTemplate.start() field is called. If you are running your server as a module, it should be noted that commonly a global start() method is used and returns this server, and dev is where this module is loaded, served, and revised.</p><p><strong>Consistencies</strong></p><ul><li>routes::Dict - The server&#39;s route =&gt; function dictionary.</li><li>extensions::Dict - The server&#39;s currently loaded extensions.</li><li>server::Any - The server, whatever type it may be...</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.WebServer" href="#Toolips.WebServer"><code>Toolips.WebServer</code></a> — <span class="docstring-category">Type</span></header><section><div></div></section></article><p>We can also call some methods on a <strong>WebServer</strong> in order to change our routes</p><h2 id="server-extensions"><a class="docs-heading-anchor" href="#server-extensions">server extensions</a><a id="server-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#server-extensions" title="Permalink"></a></h2><p>All server extensions have the following consistencies:</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.ServerExtension" href="#Toolips.ServerExtension"><code>Toolips.ServerExtension</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type ServerExtension</strong></p><p>Server extensions are loaded into the server on startup, and can have a few different abilities according to their type field&#39;s value. This value can be either a Symbol or a Vector of Symbols.</p><p><strong>Consistencies</strong></p><ul><li>type::T where T == Vector{Symbol}  || T == Symbol</li></ul></div></section></article><p>There are also a few default extensions included with toolips. These can be used by passing them in a Symbol-labeled dictionary as the extensions key-word argument on a <strong>ServerTemplate</strong> These are Logger and Files.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.Logger" href="#Toolips.Logger"><code>Toolips.Logger</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Logger</strong></p><p>out::String levels::Dict log::Function A Logger logs information with different levels. Holds the function log(), connected to the function _log(). Methods:</p><ul><li>log(::Int64, ::String)</li><li>log(::String)</li><li>log(::HTTP.Stream, ::String)</li></ul><p><strong>example</strong></p><hr/><p><strong>field info</strong></p><ul><li>out::String - Logfile output directory.</li><li>log::Function -</li></ul><p>Writes to HTML console, and also logs at level 1 with logger.</p><ul><li>levels::Dict</li></ul><hr/><p><strong>constructors</strong></p><p>Logger(levels::Dict{level_count::Int64 =&gt; crayon::Crayons.Crayon};                     out::String = pwd() * &quot;logs/log.txt&quot;) Logger(; out::String = pwd() * &quot;/logs/log.txt&quot;)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.Files" href="#Toolips.Files"><code>Toolips.Files</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Files</strong></p><p>type::Symbol directory::String f::Function –––––––––</p><ul><li>type::Symbol - The type of extension. There are three different selections</li></ul><p>you can choose from. <strong>:connection :routing :func</strong>. A :connection extension will be provided in Connection.extensions. A :routing function is passed a Dict of routes as an argument. The last is a function argument, which is just a specific function to run from the top-end to the server.</p><ul><li>directory::String - The directory to route the files from.</li><li>f::Function - The function f() called with a Connection.</li></ul><hr/><p><strong>constructors</strong></p><p>Files(dir::String)</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../projects/">« projects</a><a class="docs-footer-nextpage" href="../servables/">servables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 15 June 2022 04:11">Wednesday 15 June 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
