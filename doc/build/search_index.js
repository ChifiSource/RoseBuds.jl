var documenterSearchIndex = {"docs":
[{"location":"core/#core","page":"core","title":"core","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Below is a runthrough of all of the documentation pertaining to running a Toolips server.","category":"page"},{"location":"core/#requests","page":"core","title":"requests","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Toolips has some bindings that pre-parse responses fro you, these are both post and get requests.","category":"page"},{"location":"core/","page":"core","title":"core","text":"get\npost","category":"page"},{"location":"core/#Base.get","page":"core","title":"Base.get","text":"Interface\n\nget() -> ::Dict\n\n\n\nQuick binding for an HTTP GET request.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.post","page":"core","title":"Toolips.post","text":"Interface\n\npost() ->\n\n\n\nQuick binding for an HTTP POST request.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#connections","page":"core","title":"connections","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Connection","category":"page"},{"location":"core/#Toolips.Connection","page":"core","title":"Toolips.Connection","text":"Connection\n\nroutes::Dict\nhttp::HTTP.Stream\nextensions::Dict\n\nThe connection type is passed into route functions and pages as an argument. This is both for functions, as well as Servable.f() methods. This constructor     should not be called directly. Instead, it is called by the server and     passed through the function pipeline. Indexing a Connection will return         the extension named with that symbol.\n\nexample\n\n                  #  v The Connection\nhome = route(\"/\") do c::Connection\n    c[Logger].log(1, \"We can index extensions by type or symbol\")\n    c[:logger].log(1, \"see?\")\n    c.routes[\"/\"] = c::Connection -> write!(c, \"rerouting!\")\n    httpstream = c.http\n    write!(c, \"Hello world!\")\n    myheading::Component = h(\"myheading\", 1, text = \"Whoa!\")\n    write!(c, myheading)\nend\n\n\n\nfield info\n\nroutes::Dict - A dictionary of routes where the keys\n\nare the routed URL and the values are the functions to those keys.\n\nhttp::HTTP.Stream - The stream for this current peer's connection.\nextensions::Dict - A dictionary of extensions to load with the\n\nname to reference as keys and the extension as the pair.\n\nconstructors\n\nConnection(routes::Dict, http::HTTP.Stream, extensions::Dict)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"Connections are served as an argument to incoming routes. Functions are written anticipating a connection return. Here we will write a new route using the route(::Function, ::String) method.","category":"page"},{"location":"core/","page":"core","title":"core","text":"using Toolips\nr = route(\"/\") do c::Connection\n    write!(c, \"Hello!\")\nend","category":"page"},{"location":"core/","page":"core","title":"core","text":"We also use the write!() method on our Connection. We can use this on the types ::Any, ::Vector{Servable}, and ::Servable.","category":"page"},{"location":"core/","page":"core","title":"core","text":"write!(::Connection, ::Any)\nwrite!(::Connection, ::String)\nwrite!(::Connection, ::Servable ...)\nwrite!(::Connection, ::Vector{Servable})\nwrite!(::Connection, ::Servable)","category":"page"},{"location":"core/#Toolips.write!-Tuple{Connection, Any}","page":"core","title":"Toolips.write!","text":"Interface\n\nwrite!(::Connection, ::Any) -> _\n\n\n\nAttempts to write any type to the Connection's stream.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.write!-Tuple{Connection, String}","page":"core","title":"Toolips.write!","text":"Interface\n\nwrite!(::Connection, ::String) -> _\n\n\n\nWrites the String into the Connection as HTML.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.write!-Tuple{Connection, Vararg{Servable}}","page":"core","title":"Toolips.write!","text":"\n\n\n\n","category":"method"},{"location":"core/#Toolips.write!-Tuple{Connection, Vector{Servable}}","page":"core","title":"Toolips.write!","text":"Interface\n\nwrite!(c::Connection, s::Vector{Servable}) -> _\n\n\n\nWrites, in order of element, each Servable inside of a Vector of Servables.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.write!-Tuple{Connection, Servable}","page":"core","title":"Toolips.write!","text":"Interface\n\nwrite!(::Connection, ::Servable) -> _\n\n\n\nWrites a Servable's return to a Connection's stream.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"core","title":"core","text":"Or push any data response into a body and startread the body.","category":"page"},{"location":"core/","page":"core","title":"core","text":"push!(::Connection, ::Any)\nstartread!(::Connection, ::Any)","category":"page"},{"location":"core/#Base.push!-Tuple{Connection, Any}","page":"core","title":"Base.push!","text":"\n\n\n\n","category":"method"},{"location":"core/","page":"core","title":"core","text":"The connection type can be indexed with Symbols, Strings, and Types. Symbols and Types will index the extensions. Strings will index the routes. The same goes for setting the indexes.","category":"page"},{"location":"core/","page":"core","title":"core","text":"getindex(::Connection, ::Symbol)\ngetindex(::Connection, ::Type)\ngetindex(::Connection, ::String)","category":"page"},{"location":"core/#Base.getindex-Tuple{Connection, Symbol}","page":"core","title":"Base.getindex","text":"\n\n\n\n","category":"method"},{"location":"core/#Base.getindex-Tuple{Connection, String}","page":"core","title":"Base.getindex","text":"\n\n\n\n","category":"method"},{"location":"core/","page":"core","title":"core","text":"We also use the Connection in order to get arguments, download files, and pretty much anything else pertaining to a person's connection.","category":"page"},{"location":"core/","page":"core","title":"core","text":"getarg\ngetargs\ngetip\npostarg\ngetpost\npostargs\ndownload!\nnavigate!","category":"page"},{"location":"core/#Toolips.getarg","page":"core","title":"Toolips.getarg","text":"Interface\n\ngetargs(::Connection, ::Symbol) -> ::Dict\n\n\n\nReturns the requested arguments from the target.\n\nexample\n\n\n\n\n\nInterface\n\ngetarg(::Connection, ::Symbol, ::Type) -> ::Vector\n\n\n\nThis method is the same as getargs(::HTTP.Stream, ::Symbol), however types are parsed as type T(). Note that \"Cannot convert...\" errors are possible with this method.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getargs","page":"core","title":"Toolips.getargs","text":"Interface\n\ngetargs(::Connection) -> ::Dict\n\n\n\nThe getargs method returns arguments from the HTTP header (GET requests.) Returns a full dictionary of these values.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getip","page":"core","title":"Toolips.getip","text":"\n\n\n\n","category":"function"},{"location":"core/#Toolips.postarg","page":"core","title":"Toolips.postarg","text":"Interface\n\npostarg(::Connection, ::String) -> ::Any\n\n\n\nGet a body argument of a POST response by name.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.postargs","page":"core","title":"Toolips.postargs","text":"Interface\n\npostargs(::Connection, ::Symbol, ::Type) -> ::Dict\n\n\n\nGet arguments from the request body.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.navigate!","page":"core","title":"Toolips.navigate!","text":"Interface\n\nnavigate!(::Connection, ::String) -> _\n\n\n\nRoutes a connected stream to a given URL.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/","page":"core","title":"core","text":"We can also check if an extension is present by type.","category":"page"},{"location":"core/","page":"core","title":"core","text":"has_extension(::Connection, ::Type)","category":"page"},{"location":"core/#routing","page":"core","title":"routing","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"When routing, many methods involve the Connection type we just spoke of. In toolips, routes are handled by the Route type.","category":"page"},{"location":"core/","page":"core","title":"core","text":"Route","category":"page"},{"location":"core/#Toolips.Route","page":"core","title":"Toolips.Route","text":"Route{T}\n\npath::String\npage::T A route is added to a ServerTemplate using either its constructor, or the\n\nServerTemplate.add(::Route) method. Each route calls either a particular servable or function; the type of which denoted by T. The Route type is     commonly constructed using the do syntax with the route(::Function, String)     method.\n\nexample\n\n# Constructors\nroute = Route(\"/\", p(text = \"hello\"))\n\nfunction example(c::Connection)\n    write!(c, \"hello\")\nend\n\nroute = Route(\"/\", example)\n\n# method\nroute = route(\"/\") do c\n    write!(c, \"Hello world!\")\n    write!(c, p(text = \"hello\"))\n    # we can also use extensions!\n    c[:logger].log(\"hello world!\")\nend\n\n\n\nfield info\n\npath::String\n\nThe path, e.g. \"/\" at which to direct to the given component.\n\npage::T (::Function || T <: Component)\n\nThe servable to serve at this given route.\n\nconstructors\n\nRoute(path::String, f::Function) where\nRoute(path::String, s::Servable)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"The Route's constructors are not typically called directly, instead it is probably better to use these methods. Using route! as opposed to route! will modify the routes of a Connection or ToolipsServer","category":"page"},{"location":"core/","page":"core","title":"core","text":"route\nroute!\nunroute!","category":"page"},{"location":"core/#Toolips.route","page":"core","title":"Toolips.route","text":"Interface\n\nroute(::Function, ::String) -> ::Route\n\n\n\nCreates a route from the Function.\n\nexample\n\n\n\n\n\n\n\n\n\nInterface\n\nroute(::String, ::Servable) -> ::Route\n\n\n\nCreates a route from a Servable.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.route!","page":"core","title":"Toolips.route!","text":"Interface\n\nroute!(::Connection, ::Route) -> _\n\n\n\nModifies the routes on the Connection.\n\nexample\n\n\n\n\n\nInterface\n\nroute!(::Function, ::Connection, ::String) -> _\n\n\n\nRoutes a given String to the Function.\n\nexample\n\n\n\n\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.unroute!","page":"core","title":"Toolips.unroute!","text":"Interface\n\nunroute!(::Connection, ::String) -> _\n\n\n\nRemoves the route with the key equivalent to the String.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"core/#servers","page":"core","title":"servers","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"ToolipsServers are created by ServerTemplates. Here is a look at how to make a ServerTemplate:","category":"page"},{"location":"core/","page":"core","title":"core","text":"ServerTemplate","category":"page"},{"location":"core/#Toolips.ServerTemplate","page":"core","title":"Toolips.ServerTemplate","text":"ServerTemplate\n\nip::String\nport::Integer\nroutes::Vector{Route}\nextensions::Dict\nremove::Function\nadd::Function\nstart::Function The ServerTemplate is used to configure a server before\n\nrunning. These are usually made and started inside of a main server file.\n\nexample\n\n\n\nfield info\n\nip::String\nport::Integer\nroutes::Vector{Route}\nextensions::Dict\nremove::Function\nadd::Function\nstart::Function\n\n\n\nconstructors\n\nServerTemplate(ip::String = \"127.0.0.1\", port::Int64 = 8001,             routes::Dict = Vector{Route}()); extensions::Dict = Dict(:logger => Logger())\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"The ServerTemplate.start() function returns a sub-type of ToolipsServer.","category":"page"},{"location":"core/","page":"core","title":"core","text":"ToolipsServer\nWebServer","category":"page"},{"location":"core/#Toolips.ToolipsServer","page":"core","title":"Toolips.ToolipsServer","text":"abstract type ToolipsServer\n\nToolipsServers are returned whenever the ServerTemplate.start() field is called. If you are running your server as a module, it should be noted that commonly a global start() method is used and returns this server, and dev is where this module is loaded, served, and revised.\n\nConsistencies\n\nroutes::Dict - The server's route => function dictionary.\nextensions::Dict - The server's currently loaded extensions.\nserver::Any - The server, whatever type it may be...\n\n\n\n\n\n","category":"type"},{"location":"core/#Toolips.WebServer","page":"core","title":"Toolips.WebServer","text":"\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"We can also call some methods on a WebServer in order to change our routes","category":"page"},{"location":"core/#server-extensions","page":"core","title":"server extensions","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"All server extensions have the following consistencies:","category":"page"},{"location":"core/","page":"core","title":"core","text":"ServerExtension","category":"page"},{"location":"core/#Toolips.ServerExtension","page":"core","title":"Toolips.ServerExtension","text":"abstract type ServerExtension\n\nServer extensions are loaded into the server on startup, and can have a few different abilities according to their type field's value. This value can be either a Symbol or a Vector of Symbols.\n\nConsistencies\n\ntype::T where T == Vector{Symbol}  || T == Symbol\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"There are also a few default extensions included with toolips. These can be used by passing them in a Symbol-labeled dictionary as the extensions key-word argument on a ServerTemplate These are Logger and Files.","category":"page"},{"location":"core/","page":"core","title":"core","text":"Logger\nFiles","category":"page"},{"location":"core/#Toolips.Logger","page":"core","title":"Toolips.Logger","text":"Logger\n\nout::String levels::Dict log::Function A Logger logs information with different levels. Holds the function log(), connected to the function _log(). Methods:\n\nlog(::Int64, ::String)\nlog(::String)\nlog(::HTTP.Stream, ::String)\n\nexample\n\n\n\nfield info\n\nout::String - Logfile output directory.\nlog::Function -\n\nWrites to HTML console, and also logs at level 1 with logger.\n\nlevels::Dict\n\n\n\nconstructors\n\nLogger(levels::Dict{level_count::Int64 => crayon::Crayons.Crayon};                     out::String = pwd() * \"logs/log.txt\") Logger(; out::String = pwd() * \"/logs/log.txt\")\n\n\n\n\n\n","category":"type"},{"location":"core/#Toolips.Files","page":"core","title":"Toolips.Files","text":"Files\n\ntype::Symbol directory::String f::Function –––––––––\n\ntype::Symbol - The type of extension. There are three different selections\n\nyou can choose from. :connection :routing :func. A :connection extension will be provided in Connection.extensions. A :routing function is passed a Dict of routes as an argument. The last is a function argument, which is just a specific function to run from the top-end to the server.\n\ndirectory::String - The directory to route the files from.\nf::Function - The function f() called with a Connection.\n\n\n\nconstructors\n\nFiles(dir::String)\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#developer-api","page":"developer api","title":"developer api","text":"","category":"section"},{"location":"developer_api/","page":"developer api","title":"developer api","text":"Welcome to the Toolips developer API. If you are looking to make a toolips website, you've probably stumbled into the wrong place unless of course you need to create an extension for your site. There are three main types of toolips extensions.","category":"page"},{"location":"developer_api/","page":"developer api","title":"developer api","text":"Servable Extensions\n","category":"page"},{"location":"developer_api/#creating-servable-extensions","page":"developer api","title":"creating servable extensions","text":"","category":"section"},{"location":"developer_api/#creating-server-extensions","page":"developer api","title":"creating server extensions","text":"","category":"section"},{"location":"developer_api/#toolips-internals","page":"developer api","title":"toolips internals","text":"","category":"section"},{"location":"toolips_session/#toolips-session-extension","page":"sessions","title":"toolips session extension","text":"","category":"section"},{"location":"toolips_session/","page":"sessions","title":"sessions","text":"The ToolipsModifier is an extension that is loaded into","category":"page"},{"location":"#toolips-docs","page":"toolips","title":"toolips docs","text":"","category":"section"},{"location":"#a-manic-web-development-framework","page":"toolips","title":"a manic web-development framework","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Toolips.jl is a reactive. full-stack, modular and extendable web-development framework written in pure Julia.","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"","category":"page"},{"location":"#tutorials","page":"toolips","title":"tutorials","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Basics - Creating an API\nBasics - Building a static site\nIntermediate - Building Your First WebApp\nAdvanced - Creating a ServerExtension","category":"page"},{"location":"#curated-projects","page":"toolips","title":"curated projects","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Below are some curated and deployed toolips apps and toolips extensions that can be used as examples or loaded as a server extension to look into.","category":"page"},{"location":"#modules","page":"toolips","title":"modules","text":"","category":"section"},{"location":"#sites","page":"toolips","title":"sites","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"EmsComputer.jl - ems computer\nToolipsApp.jl - toolips app","category":"page"},{"location":"#server-extensions","page":"toolips","title":"server extensions","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsModifier.jl - Reactive Components.\nToolipsRemote.jl - Allows remote management of a Toolips server via a","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"regular HTTP request.","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsDefaults.jl - More style components, and style default methods.","category":"page"},{"location":"#servables","page":"toolips","title":"servables","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsDefaults.jl - More style components, and style default methods.\nToolipsCanvas.jl - Interact with the Canvas element via script.","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"Toolips","category":"page"},{"location":"#Toolips","page":"toolips","title":"Toolips","text":"Created in February, 2022 by chifi - an open source software dynasty. by team toolips This software is MIT-licensed.\n\nToolips\n\nToolips.jl is a fast, asynchronous, low-memory, full-stack, and reactive web-development framework always written in pure Julia.\n\nModule Composition\n\nToolips\n\n\n\n\n\n","category":"module"},{"location":"servables/#servables","page":"servables","title":"servables","text":"","category":"section"},{"location":"servables/","page":"servables","title":"servables","text":"Servables are any non-core data-structure that is built with the objective of being written to a stream.","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"Servable","category":"page"},{"location":"servables/#Toolips.Servable","page":"servables","title":"Toolips.Servable","text":"abstract type Servable\n\nServables can be written to a Connection via thier f() function and the interface. They can also be indexed with strings or symbols to change properties\n\nConsistencies\n\nf::Function - Function whose output to be written to http().\n\n\n\n\n\n","category":"type"},{"location":"servables/#components","page":"servables","title":"components","text":"","category":"section"},{"location":"servables/","page":"servables","title":"servables","text":"A component is a Servable which contains markup information and can easily be translated into elements with properties..","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"Component","category":"page"},{"location":"servables/#Toolips.Component","page":"servables","title":"Toolips.Component","text":"Component <: Servable\n\nname::String f::Function properties::Dict –––––––––\n\nname::String - The name field is the way that a component is denoted in code.\nf::Function - The function that gets called with the Connection as an\n\nargument.\n\nproperties::Dict - A dictionary of symbols and values.\n\n\n\nconstructors\n\nComponent(name::String, tag::String, properties::Dict)\n\n\n\n\n\n","category":"type"},{"location":"servables/","page":"servables","title":"servables","text":"Indexing a component will yield its .properties:","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"getindex(::Servable, ::Symbol)\ngetindex(::Servable, ::String)\nsetindex!(::Servable, ::Any, ::Symbol)\nsetindex!(::Servable, ::Any, ::Symbol)\nsetindex!(::Servable, ::Any, ::String)","category":"page"},{"location":"servables/#Base.getindex-Tuple{Servable, Symbol}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(::Servable, ::Symbol) -> ::Any\n\n\n\nReturns a property value by symbol or name.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"servables/#Base.getindex-Tuple{Servable, String}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(::Servable, ::String) -> ::Any\n\n\n\nReturns a property value by string or name.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"servables/#Base.setindex!-Tuple{Servable, Any, Symbol}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(::Servable, ::Symbol, ::Any) -> ::Any\n\n\n\nSets the property represented by the symbol to the provided value.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"servables/#Base.setindex!-Tuple{Servable, Any, String}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(::Servable, ::String, ::Any) -> ::Any\n\n\n\nSets the property represented by the string to the provided value.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"servables/","page":"servables","title":"servables","text":"There is a library of default components that comes with toolips. Generally, their name coincides with a docstring. All of these take an infinite number of key-word arguments. These arguments become the properties of a Servable.","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"img\nlink\nmeta\ninput\na\np\nh\nimg\nul\nli\ndivider\nbr\ni\ntitle\nspan\niframe\nsvg\nelement\nlabel\nscript\nnav\nbutton\nform","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"We can also compose components together using push! and style them using style!","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"push!(::Servable, ::Servable)\npush!(::Servable, ::Vector{Servable})\npush!(::Component, ::Servable ...)\nproperties!(::Servable, ::Servable)\npush!(::Component, ::Servable)\nstyle!","category":"page"},{"location":"servables/#Base.push!-Tuple{Component, Vararg{Servable}}","page":"servables","title":"Base.push!","text":"Interface\n\npush!(::Component, ::Component ...) -> ::Component\n\n\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"servables/#Toolips.properties!-Tuple{Servable, Servable}","page":"servables","title":"Toolips.properties!","text":"Interface\n\nproperties!(::Servable, ::Servable) -> _\n\n\n\nCopies properties from s,properties into c.properties.\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"servables/#Base.push!-Tuple{Component, Servable}","page":"servables","title":"Base.push!","text":"Interface\n\npush!(::Component, ::Component) ->\n\n\n\nexample\n\n\n\n\n\n","category":"method"},{"location":"servables/#Toolips.style!","page":"servables","title":"Toolips.style!","text":"Interface\n\nstyle!(::Servable, ::Style) -> _\n\n\n\nApplies the style to a servable.\n\nexample\n\n\n\n\n\n\n\n\n\nInterface\n\nstyle!(::Style, ::Style) -> _\n\n\n\nCopies the properties from the second style into the first style.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"servables/#style-components","page":"servables","title":"style components","text":"","category":"section"},{"location":"servables/","page":"servables","title":"servables","text":"Style components are change the style of a Component","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"StyleComponent","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"The main style components are Animations and Styles.","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"Animation","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"Animating and property adjustment is done with indexing.","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"","category":"page"},{"location":"servables/#file","page":"servables","title":"file","text":"","category":"section"},{"location":"servables/","page":"servables","title":"servables","text":"The file Servable, as you might expect, serves a file via a directory.","category":"page"},{"location":"servables/","page":"servables","title":"servables","text":"File","category":"page"},{"location":"servables/#Toolips.File","page":"servables","title":"Toolips.File","text":"File <: Servable\n\ndir::String f::Function –––––––––\n\nfield info\n\ndir::String - The directory of a file to serve.\nf::Function - Function whose output to be written to http().\n\n\n\nconstructors\n\nFile(dir::String)\n\n\n\n\n\n","category":"type"},{"location":"projects/#projects","page":"projects","title":"projects","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Projects in Toolips are easy to start. You can either choose to create a project directory structure, or optionally; you can create an entire server inside of your REPL!","category":"page"},{"location":"projects/#creating-a-project","page":"projects","title":"creating a project","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects are created using the newapp and newwebapp methods respectively. newapp will create a simple project and newwebapp will create a full-stack web-app.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips.new_app","category":"page"},{"location":"projects/#Toolips.new_app","page":"projects","title":"Toolips.new_app","text":"new_app(::String) -> _\n\n\n\nCreates a minimalistic app, usually used for creating endpoints – but can be used for anything. For an app with a real front-end, it might make sense to add some extensions.\n\nexample\n\nusing Toolips\nToolips.new_app(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips.new_webapp","category":"page"},{"location":"projects/#Toolips.new_webapp","page":"projects","title":"Toolips.new_webapp","text":"new_webapp(::String) -> _\n\n\n\nCreates a fully-featured web-app. Adds ToolipsModifier, ideal for full-stack web-sites.\n\nexample\n\nusing Toolips\nToolips.new_webapp(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"projects/#project-tutorials","page":"projects","title":"project tutorials","text":"","category":"section"},{"location":"projects/#a-repl-crash-course","page":"projects","title":"a repl crash course","text":"","category":"section"},{"location":"projects/#project-walkthrough","page":"projects","title":"project walkthrough","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects  work just like any other Julia project. There is no random silliness going on here – no need to source anything with Bash, merely call Julia. After running newapp or newwebapp, you should be greeted with a new directory named after your project name.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Pkg; Pkg.add(\"Toolips\")\nusing Toolips\nToolips.new_webapp(\"ToolipsTutorial\")","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"cd ToolipsTutorial\n~/dev/ToolipsTutorial\n\ntree .\n[.]\n├── dev.jl\n├── prod.jl\n├── Manifest.toml\n├── Project.toml\n├── [logs]\n│   └── log.txt\n├── [public]\n└── [src]\n    └── ToolipsTutorial.jl\n\n3 directories, 6 files\n","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The directory structure is that of a typical Julia project – albeit with a few extra little files and folders. The source code that creates our websites is contained within the src directory. A Logger comes loaded as a default extension, although we could remove it if we really wanted to, or likewise – create our own Logger and load it as an extension – which is pretty much what makes toolips great. The Logger by default will log to the logs directory. The public directory contains any files we want to be served automatically by the Files ServerExtension. This directory will be missing if you decide to utilize the new_app method. The other two things that are not Julia defaults are the files dev.jl and prod.jl. These are environment files, they store environmental variables to be sourced above the module in Main. Let's take a look:","category":"page"},{"location":"projects/#dev.jl","page":"projects","title":"dev.jl","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"#==\ndev.jl is an environment file. This file loads and starts servers, and\ndefines environmental variables, setting the scope a lexical step higher\nwith modularity.\n==#\nusing Pkg; Pkg.activate(\".\")\nusing Toolips\nusing Revise\nusing ToolipsModifier\nusing ToolipsTutorial\n\nIP = \"127.0.0.1\"\nPORT = 8000\n#==\nExtension description\n:logger -> Logs messages into both a file folder and the terminal.\n:public -> Routes the files from the public directory.\n:mod -> ToolipsModifier; allows us to make Servables reactive. See ?(on)\n==#\nextensions = Dict(:logger => Logger(), :public => Files(\"public\"),\n:mod => Modifier())\nToolipsTutorialServer = ToolipsTutorial.start(IP, PORT, extensions)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Firstly, dev.jl activates the project environment with Pkg. Next, we load all of the dependencies. The first one is the most obvious; you are reading the documentation for it. The second one is Revise. Revise.jl allows us to update our modules while they are loaded into main. This just makes rerouting easier, as you can modify the text file, save it, update the routes, and then your new website is up with no downtime. No worries, I will be showing how this is done in no time. First though, we will also consider the extensions section. I have been kind enough to leave a little note here,","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Extension description\n:logger -> Logs messages into both a file folder and the terminal.\n:public -> Routes the files from the public directory.\n:mod -> ToolipsModifier; allows us to make Servables reactive. See ?(on)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"This describes what each extension does. Of course, all the effort it takes to add more is merely adding them via Pkg and adding them to this dictionary. We are going to include this file in order to start the server. We would include prod.jl if we wanted to start a production server, which is a very similar file in content, jut missing the Revise.jl First, let us take a look at the source file.","category":"page"},{"location":"projects/#src.jl","page":"projects","title":"src.jl","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"module ToolipsTutorial\nusing Toolips\nusing ToolipsModifier\n\nfunction home(c::Connection)\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\nend\n\nfourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend\n\n\"\"\"\nstart()\n\"\"\"\nfunction start(IP::String = \"127.0.0.1\", PORT::Integer = 8000,\n    extensions::Dict = Dict(:logger => Logger()))\n    rs = routes(route(\"/\", home), fourofour)\n    server = ServerTemplate(IP, PORT, rs, extensions = extensions)\n    server.start()\nend\n\nend # - module","category":"page"},{"location":"projects/#start","page":"projects","title":"start","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"This file will likely look a bit different in the future, with a bit more documentation, and maybe a more illustrious default project, but do not fret – the names will all be the same and the file similar enough! The start function is probably the most important here. This function constructs our Routes, makes a ServerTemplate and then runs ServerTemplate.start(), returning a WebServer. Back up in dev.jl we see that this is aptly named \"projectnameServer\"","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"extensions = Dict(:logger => Logger(), :public => Files(\"public\"),\n:mod => Modifier())\nToolipsTutorialServer = ToolipsTutorial.start(IP, PORT, extensions)","category":"page"},{"location":"projects/#home","page":"projects","title":"home","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"function home(c::Connection)\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The home function is a function built to be routed to. We can tell this is the ] case because it takes a Connection as its only argument. This is one method of making a route. Inside the function, c is written to using the write! method. Keep this method in mind, as we will be using it a lot; it is the primary output for toolips. There is also a component constructed via the p() method. This just creates a p. The id of the p will be its name, \"helloworld\", and the text; which modifies the inner text of a given element. The other special key is :children, which is of type Vector{Servable}. This will be any children to write to the stream inside of this tag. Children are usually added via the push!(::Servable, ::Servable) method.","category":"page"},{"location":"projects/#fourofour","page":"projects","title":"fourofour","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"fourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The fourofour is made as a global variable of type Route, rather than as a function.","category":"page"},{"location":"projects/#command-line-interface","page":"projects","title":"command line interface","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"We have a few different options when it comes to starting the server. These options of course come with all toolips servers. The first of which is to load a server as a module. Most modular servers will use the Module.start() method, just like our project ToolipsTutorial does above. This is ideal if","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You want to try someone else's Toolips Application.\nThe module you are working with is an Application.\nThe module you are working with is an extension; then the module is used","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"inside of another project, just to be clear.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Pkg\nPkg.add(url = \"https://github.com/ChifiSource/ToolipsApp.jl\")\nusing ToolipsApp\nToolipsAppServer = ToolipsApp.start()","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Alternatively, we can always git clone the repository, or with a project we started serve our project. This is ideal if","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You want to put the server into production.\nYou want to develop the project. \n","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"We can start the server in this way by utilizing the environment files discussed before. This is done either via the include(\"\") method in the REPL, or via the -L parameter in Bash.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"pwd()\n\"~/dev/ToolipsTutorial\"\ninclude(\"dev.jl\")\n#==\n[ Info: Precompiling ToolipsTutorial [9dd80660-3bd1-4940-be1d-3a5faeb076a0]\n[2022-06-14T18:50:45.970]: Toolips Server starting on port 8000\n[2022-06-14T18:50:46.521]: Successfully started server on port 8000\n[2022-06-14T18:50:46.966]: You may visit it now at http://127.0.0.1:8000\n==#","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"julia -L dev.jl\n[ Info: Precompiling ToolipsTutorial [9dd80660-3bd1-4940-be1d-3a5faeb076a0]\n[2022-06-14T18:50:45.970]: Toolips Server starting on port 8000\n[2022-06-14T18:50:46.521]: Successfully started server on port 8000\n[2022-06-14T18:50:46.966]: You may visit it now at http://127.0.0.1:8000","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Wow now you can see the exact date and time at which I did that, cool. Anyway, with our new toolips server running, we can introspect its routes:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"ToolipsTutorialServer.routes\nDict{String, Function} with 3 entries:\n  \"404\"              => #1\n  \"/\"                => home\n  \"/modifier/linker\" => document_linker\n  julia> typeof(ToolipsTutorialServer)\n  WebServer","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The /modifier/linker route is provided to us by our Modifier extension. We also see that the type of this new variable is WebServer. Viewing the server in the web-browser yields us a small p with a label \"hello world!\". We can also route the server using the route! method, or access extensions and routes by indexing. This is the same way we would use the route() function as is done in our source file. We access Connection extensions by indexing a Connection with a Symbol. We can also access and change routes by indexing with a String. This same methodology is also applied to the WebServer, so we can index it in the same way, as well.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"route!(ToolipsTutorialServer, \"/cupcakes\") do c::Connection\n    write!(c, \"emmy LOVES CUPCAAAKES\")\n    c[:logger].log(1, \"hello\")\nend\n\n[2022-06-14T19:29:32.180]: hello\n\"emmy LOVES CUPCAAAKES\"","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Let's develop our emmy loves cupcakes app a bit further, by instead making it our project route function. Don't close up the REPL, though! we will still be using it!","category":"page"},{"location":"projects/#making-applications","page":"projects","title":"making applications","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Lets return to our project source file,","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"function home(c::Connection)\n    redclass = Style(\"redtxt\", color = \"red\")\n    blueclass = Style(\"bluetxt\", color = \"lightblue\")\n    heading = h(\"cupkakes\", 1, text = \"Cupcakes\")\n    write!(c, p(\"clicktod\",\n    text = \"click to make the heading change color; double click to send to red.\"))\n    write!(c, components(redclass, blueclass))\n    on(c, heading, \"click\") do cm::ComponentModifier\n        style!(cm, heading, blueclass)\n    end\n    on(c, heading, \"dblclick\") do cm::ComponentModifier\n        style!(cm, heading, redclass)\n    end\n    write!(c, heading)\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Here I added an on() method call. This method call allows us to modify components on events. In this example, clicking will make the heading invisible. It is incredibly easy, but incredibly possible!","category":"page"},{"location":"projects/#deploying-a-toolips-server","page":"projects","title":"deploying a toolips server","text":"","category":"section"}]
}
